// Generated by CoffeeScript 1.6.2
(function() {
  var NoTabs, vars,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  vars = require('./vars.js');

  module.exports = NoTabs = (function() {
    function NoTabs() {}

    NoTabs.prototype.rule = {
      name: 'undefined_variables',
      allowHoisting: false,
      level: 'error',
      message: 'Undefinded variable',
      description: 'Detect undefined variables'
    };

    NoTabs.prototype.lintAST = function(node, astApi) {
      var defineAll,
        _this = this;

      this.astApi = astApi;
      this.depth = 0;
      this.scopes = [];
      this.newScope();
      defineAll = function(list) {
        var v, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          v = list[_i];
          _results.push(_this.currentScope[v] = {
            defined: -1,
            used: true
          });
        }
        return _results;
      };
      vars.reservedVars.push('this');
      defineAll(vars.reservedVars);
      defineAll(vars.ecmaIdentifiers);
      defineAll(vars.browser);
      defineAll(vars.devel);
      defineAll(vars.node);
      this.lintNode(node);
      this.popScope();
      if (this.scopes.length !== 0) {
        throw new Error("Error walking AST for undefined_variables");
      }
      return void 0;
    };

    NoTabs.prototype.newScope = function() {
      var Scope, cs, parentScope, _ref;

      parentScope = this.currentScope;
      Scope = function() {};
      if (parentScope != null) {
        Scope.prototype = parentScope;
      }
      cs = new Scope;
      this.scopes.push(cs);
      this.currentScope = cs;
      console.assert((_ref = this.currentScope, __indexOf.call(this.scopes, _ref) >= 0), 'foo');
      return void 0;
    };

    NoTabs.prototype.newVariable = function(variable, options) {
      var base, index, name, p, _ref, _ref1;

      if (options == null) {
        options = {};
      }
      if (variable == null) {
        return;
      }
      base = variable.base;
      name = base.value;
      if (((_ref = variable.properties) != null ? _ref.length : void 0) > 0) {
        this.checkExists(variable.base);
        _ref1 = variable.properties;
        for (index in _ref1) {
          p = _ref1[index];
          if (p.index != null) {
            this.checkExists(p.index.base);
          }
        }
        return;
      }
      if (name != null) {
        if (this.currentScope[name] == null) {
          options.defined = base.locationData.first_line + 1;
          options.used = false;
          return this.currentScope[name] = options;
        }
      }
    };

    NoTabs.prototype.popScope = function() {
      var current, data, exitingScope, name;

      exitingScope = this.scopes.pop();
      this.currentScope = this.scopes[this.scopes.length - 1];
      for (name in exitingScope) {
        if (!__hasProp.call(exitingScope, name)) continue;
        data = exitingScope[name];
        if (!data.used) {
          current = data;
          while ((current != null) && current.used === false) {
            current = exitingScope[current.dependsOn];
          }
          if (!(current != null ? current.used : void 0)) {
            this.errors.push(this.astApi.createError({
              context: name,
              message: 'Unused variable',
              lineNumber: data.defined
            }));
          }
        }
      }
      return void 0;
    };

    NoTabs.prototype.checkExists = function(base) {
      var value;

      value = base != null ? base.value : void 0;
      if ((base == null) || (base != null ? typeof base.isAssignable === "function" ? base.isAssignable() : void 0 : void 0) === false) {
        return true;
      }
      if ((value != null) && (this.currentScope[value] != null)) {
        this.currentScope[value].used = true;
      } else if (value != null) {
        this.errors.push(this.astApi.createError({
          context: value,
          message: 'Undefined variable',
          lineNumber: base.locationData.first_line + 1
        }));
        return false;
      }
      return true;
    };

    NoTabs.prototype.lintNode = function(node) {
      var arg, commentRegex, exp, lastParam, line, name, o, param, recurseValues, tmp, variable, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
        _this = this;

      name = node.constructor.name;
      if (name === 'Code') {
        this.newScope();
        lastParam = void 0;
        _ref = node.params;
        for (_i = _ref.length - 1; _i >= 0; _i += -1) {
          param = _ref[_i];
          param.base = param.name;
          this.newVariable(param, {
            dependsOn: lastParam
          });
          lastParam = param.name.value;
        }
      } else if (name === 'Block-disabled') {
        _ref1 = node.expressions;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          exp = _ref1[_j];
          if ((exp.variable != null) && (exp.value != null)) {
            void 0;
          } else if (exp.source != null) {
            this.newVariable(exp.source);
          }
        }
      } else if (name === 'Comment') {
        commentRegex = /global(?:\s[\w\d]+)*/g;
        line = node.location.first_line + 1;
        tmp = commentRegex.exec(node.comment);
        _ref2 = tmp[0].split(' ').slice(1);
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          variable = _ref2[_k];
          this.currentScope[variable] = {
            defined: line,
            used: false
          };
        }
      } else if (name === 'Class') {
        this.newVariable(node.variable);
      } else if (name === 'Assign') {
        this.checkExists(node.value);
        if (node.context !== 'object') {
          recurseValues = function(n) {
            var o, _l, _len2, _ref3;

            if (n.value != null) {
              recurseValues(n.value);
            } else {
              if (n.base.objects != null) {
                _ref3 = n.base.objects;
                for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
                  o = _ref3[_l];
                  recurseValues(o);
                }
              } else {
                _this.newVariable(n);
              }
            }
            return void 0;
          };
          if (node.variable.base.objects != null) {
            _ref3 = node.variable.base.objects;
            for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
              o = _ref3[_l];
              if (o.value != null) {
                recurseValues(o.value);
              } else {
                recurseValues(o);
              }
            }
          } else {
            this.newVariable(node.variable);
          }
        }
      } else if (name === 'Splat') {
        this.checkExists(node.name.base);
      } else if (name === 'Op') {
        this.checkExists(node.first.base);
        if (node.second != null) {
          this.checkExists(node.second.base);
        }
      } else if (name === 'If') {
        if (node.condition.expression != null) {
          this.checkExists(node.condition.expression.base);
        }
        if (node.condition.constructor.name === 'Value') {
          this.checkExists(node.condition.base);
        }
      } else if (name === 'In') {
        this.checkExists(node.object.base);
        this.checkExists(node.array.base);
      } else if (name === 'For') {
        if (node.name != null) {
          this.newVariable({
            base: node.name
          });
        }
        if (node.index != null) {
          this.newVariable({
            base: node.index
          }, {
            dependsOn: (_ref4 = node.name) != null ? _ref4.value : void 0
          });
        }
        this.checkExists(node.source.base);
      } else if (name === 'Call') {
        if (node.variable != null) {
          this.checkExists(node.variable.base);
        }
        _ref5 = node.args;
        for (_m = 0, _len3 = _ref5.length; _m < _len3; _m++) {
          arg = _ref5[_m];
          this.checkExists(arg.base);
        }
      } else {
        void 0;
      }
      this.lintChildren(node);
      if (name === 'Return') {
        if (node.expression != null) {
          this.checkExists((_ref6 = node.expression.variable) != null ? _ref6.base : void 0);
          this.checkExists(node.expression);
          this.checkExists(node.expressionbase);
        }
      } else if (name === 'Code') {
        this.popScope();
      }
      return void 0;
    };

    NoTabs.prototype.indent = function(num, suffix) {
      if (num <= 10) {
        return console.log((new Array(parseInt(num) + 1)).join(' ') + num + suffix);
      }
    };

    NoTabs.prototype.level = 0;

    NoTabs.prototype.lintChildren = function(node) {
      var _this = this;

      this.level++;
      node.eachChild(function(childNode) {
        if (childNode) {
          _this.lintNode(childNode);
        }
        return true;
      });
      return this.level--;
    };

    return NoTabs;

  })();

}).call(this);
